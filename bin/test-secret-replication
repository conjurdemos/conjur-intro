#!/usr/bin/env bash

# USAGE
#
# Given a NUMBER_OF_SECRETS, dynamically generates a Conjur Policy branch
# for the given counter. Each secret is set on the Leader, and then checked
# on each of the Followers in parallel (with up to 5 retries). If any one
# Follower fails to replicate the secret, this script will fail.
#
# IMPORTANT: the $BASE_POLICY_BRANCH is reset per run of this script. It will
# remain after the script is run. This is intentional so that
# `test-table-rows-match` has data to work with.
#
# ./test-secret-replication.sh <NUMBER_OF_SECRETS> <FOLLOWER_COUNT>
# ./test-secret-replication.sh 1 1
# ./test-secret-replication.sh 5 5
# ./test-secret-replication.sh 5 10
#

DOCKER_LEADER_CONTAINER="conjur-master-1.mycompany.local"
CONJUR_USER="admin"
CONJUR_ACCOUNT="demo"
CONJUR_PASSWORD="MySecretP@ss1"
BASE_POLICY_BRANCH="replication-test"
TEST_POLICY_BRANCH_PREFIX="secret-"
MAX_ATTEMPTS=5

# Use this to hide WARN from docker compose...
# WARN[0000] The "VERSION" variable is not set. Defaulting to a blank string. 
export VERSION=


main() {
  NUMBER_OF_SECRETS="$1"
  FOLLOWER_COUNT="$2"

  mkdir -p ./policy/bulk

  if [[ -z "$NUMBER_OF_SECRETS" ]]; then
    echo "FATAL: NUMBER_OF_SECRETS must be specified as \$1"
    exit 1
  fi

  if [[ -z "$FOLLOWER_COUNT" ]]; then
    echo "FATAL: FOLLOWER_COUNT must be specified as \$2"
    exit 1
  fi

  TOKEN=$(get_conjur_access_token)
  if [[ -z "$TOKEN" ]]; then
    echo "FATAL: Failed to get Conjur Access Token!"
    exit 1
  fi

  # Reset the base policy branch
  replace_base_policy

  # Create the base branch where tests will take place on...
  load_base_policy

  for i in $(seq 1 "$NUMBER_OF_SECRETS"); do
    echo "Loading secret $i..."
    DYNAMIC_BRANCH="${TEST_POLICY_BRANCH_PREFIX}${i}"
    POLICY_FILE=$(get_dynamic_policy "$i")

    echo "Loading the following policy..."
    echo "$POLICY_FILE"

    load_dynamic_policy "$BASE_POLICY_BRANCH" "$POLICY_FILE"
    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to load sample policy!"
      exit 1
    fi
    echo -e "\nDynamic policy '$DYNAMIC_BRANCH' was loaded successfully."
    
    # Generate a timestamp: Unix timestamp in seconds + milliseconds (last 3 digits)
    SECRET_VALUE=$(date +%s)$(awk -v min=0 -v max=999 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
    SECRET_IDENTIFIER=$(urlencode_forward_slashes_only "${BASE_POLICY_BRANCH}/${DYNAMIC_BRANCH}/secret_${i}")

    echo "Updating secret '$SECRET_IDENTIFIER' to: $SECRET_VALUE"
    set_secret "$SECRET_IDENTIFIER" "$SECRET_VALUE"

    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to set secret!"
      exit 1
    fi
    echo -e "\nSuccessfully was set successfully."

    pids=()
    for ((j=1; j<=FOLLOWER_COUNT; j++))
    do
      # Execute the following in parallel...
      FOLLOWER_HOSTNAME="conjur-follower-${j}.mycompany.local"
      echo "[$FOLLOWER_HOSTNAME] (Attempt: $j/$MAX_ATTEMPTS) - Starting job to set secret on follower $FOLLOWER_HOSTNAME..."
      (
        for ((k=1; k<=MAX_ATTEMPTS; k++))
        do
          echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - Begin checking secret '$SECRET_IDENTIFIER' on follower '$FOLLOWER_HOSTNAME'..."
          FOLLOWER_SECRET_VALUE=$(get_secret_from_follower "$FOLLOWER_HOSTNAME" "$SECRET_IDENTIFIER")

          if [[ "$FOLLOWER_SECRET_VALUE" == "$SECRET_VALUE" ]]; then
            echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - Successfully replicated secret '$SECRET_IDENTIFIER' with value '$FOLLOWER_SECRET_VALUE' to follower '$FOLLOWER_HOSTNAME'."
            break
          elif [[ "$k" -eq 5 ]]; then
            echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - FATAL: Follower $FOLLOWER_HOSTNAME failed to replicate secret_$i. Expected '$SECRET_IDENTIFIER' to be '$SECRET_VALUE', got '$FOLLOWER_SECRET_VALUE'..."
            exit 1
          fi
          echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - Retrying in 0.5 seconds..."
          sleep 0.5
        done
      ) &
      pids+=("$!")
    done

    # Wait for each job individually
    for pid in "${pids[@]}"; do
      wait "$pid"
      exit_status=$?
      if [ $exit_status -ne 0 ]; then
        echo "FATAL: A Follower failed to replicate! Exiting..."
        exit $exit_status
      fi
    done
  done
  echo "DONE."
}

replace_base_policy() {
  POLICY_BODY=$(cat <<EOF
- !policy
  id: $BASE_POLICY_BRANCH
EOF
)

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request PUT \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      --data '$POLICY_BODY' \
      https://localhost/policies/$CONJUR_ACCOUNT/policy/$BASE_POLICY_BRANCH
  "


  if [ $? -ne 0 ]; then
    echo -e "\nFATAL: Failed to reset base policy!"
    exit 1
  fi
  echo -e "\nBase policy was reset successfully."
}

load_base_policy() {
  POLICY_FILE=$(cat <<EOF
- !policy
  id: $BASE_POLICY_BRANCH
EOF
)

  load_dynamic_policy "root" "$POLICY_FILE"
  if [ $? -ne 0 ]; then
    echo -e "\nFATAL: Failed to load base policy!"
    exit 1
  fi
  echo -e "\nBase policy was loaded successfully."
}

# Conjur Access Tokens work across all Leaders/Followers. Let's get a token
# one time, and refresh it as needed. Returns a base64 encoded token.
get_conjur_access_token() {
  API_KEY=$(docker compose exec "$DOCKER_LEADER_CONTAINER" curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k https://localhost/authn/$CONJUR_ACCOUNT/login)
  docker compose exec "$DOCKER_LEADER_CONTAINER" curl \
        --max-time 3 \
        --silent \
        --insecure \
        --request POST \
        --data "$API_KEY" \
        "https://localhost/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate" | base64 | tr -d "[:space:]"
}

load_dynamic_policy() {
  POLICY_BRANCH="$1"
  POLICY_BODY="$2"

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request POST \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      --data '$POLICY_BODY' \
      https://localhost/policies/$CONJUR_ACCOUNT/policy/$POLICY_BRANCH
  "
}

get_dynamic_policy() {
  COUNTER="$1"
  cat <<EOF
- !policy
  id: $DYNAMIC_BRANCH
  annotations:
    description: Namespace defs for the Conjur cluster in dev
  body:
    - !variable
      id: secret_$COUNTER
      annotations:
        description: secret_$COUNTER description

    - !host
      id: host_$COUNTER
      annotations:
        description: host_$COUNTER description

    - !group
      id: group_$COUNTER
      annotations:
        description: group_$COUNTER description

    - !permit
      role: !group group_$COUNTER
      privilege: [ read, execute ]
      resource: !variable secret_$COUNTER
    - !grant
      role: !group group_$COUNTER
      member: !host host_$COUNTER
EOF
}

set_secret() {
  IDENTIFIER="$1"
  VALUE="$2"

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request POST \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      --data '$VALUE' \
      https://localhost/secrets/$CONJUR_ACCOUNT/variable/$IDENTIFIER
  "
  
}

get_secret_from_follower() {
  FOLLOWER_HOSTNAME="$1"
  IDENTIFIER="$2"

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      https://$FOLLOWER_HOSTNAME/secrets/$CONJUR_ACCOUNT/variable/$IDENTIFIER
  "
  
}

# WARNING: this is naive and only encodes forward slashes, and no other
# characters!
urlencode_forward_slashes_only() {
    local string="$1"
    echo "$string" | sed 's|/|%2F|g'
}

main "$@"
