#!/usr/bin/env bash

# DESCRIPTION
# Given a --follower-count, --policy-count, --secret-count and --max-attempts,
# this script will:
#
# 1) Load a dynamic policy with a secret into the Leader
# 2) Set the secret on the Leader
# 3) Verify that the secret is replicated to each Appliance Follower (parallel)
#
# If a secret did not replicate within the --max-attempts, the script will
# fail.
#
# When verifying secrets on the K8S Followers, the script will attempt to
# authenticate with the Follower to retrieve an access token.
#
# IMPORTANT: the $BASE_POLICY_BRANCH is reset per run of this script. It will
# remain after the script is run. This is intentional so that
# `test-table-rows-match` has data to work with.
#
# USAGE
# ./bin/test-secret-replication --max-attempts 10 --policy-count 2 --secret-count 2 --follower-count 2
#
# This test has been encountering issues where:
#
# 1) A Token provided by a Leader is seen as invalid, but the token
# works for other Followers. This is seen in the Follower log:
#
# conjur-follower-3.mycompany.local-1  | <14>1 2024-06-04T22:37:02.000+00:00 ffe6d49725ac conjur-possum 1058 - [meta sequenceId="39"] [origin=12.16.23.11] [request_id=bc42f74e-3da1-478e-b47d-b103b7745f33] [tid=1070] Started GET "/secrets/demo/variable/replication-test%2Fpolicy-1%2Fsecret_1" for 12.16.23.11 at 2024-06-04 22:37:02 +0000
# conjur-follower-3.mycompany.local-1  | <13>1 2024-06-04T22:37:03.622+00:00 ffe6d49725ac nginx - - [meta sequenceId="40"] 12.16.23.11 "-" "GET /secrets/demo/variable/replication-test%2Fpolicy-1%2Fsecret_1 HTTP/1.1" 401 27 "-" "curl/7.81.0" 0.028 0.028
#
# 2) A token provided by a Follower is seen as invalid. This is seen
# in the Follower log:
#
# conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="171"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094] Started GET "/authn/demo/login" for 12.16.23.11 at 2024-06-04 22:57:32 +0000
# conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="172"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094] Processing by AuthenticateController#login as */*
# conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="173"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094]   Parameters: {:controller=>"authenticate", :action=>"login", :authenticator=>"authn", :account=>"demo"}
# conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="174"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094] CONJ00047I Login Error: #<Errors::Authentication::Security::AccountNotDefined: CONJ00008E Account 'demo' is not defined in Conjur>
#
# This seems to indicate that a Follower might be in the process of
# replicating (healthily) still... so increase MAX_ATTEMPTS reasonably.
#

# Always work from repo root directory
cd "$(dirname ${0})/..";

source ./bin/functions
source ./bin/utils.sh

CONJUR_USER="admin"
CONJUR_ACCOUNT="demo"
CONJUR_PASSWORD="MySecretP@ss1"
BASE_POLICY_BRANCH="replication-test"
MAX_ATTEMPTS=

# Use this to hide WARN from docker compose...
# WARN[0000] The "VERSION" variable is not set. Defaulting to a blank string. 
export VERSION=
FOLLOWER_LOAD_SECRET_JOB_PIDS=()

POLICY_COUNT=
SECRET_COUNT=
FOLLOWER_COUNT=

cleanup_background_jobs() {
  # NOTE: this will only stop the background jobs for configuring a Follower
  # from outputting to stdout if a configuration command has begun on the
  # Follower, that process will remain running within the container. Cleanup of
  # the containers is left to the --stop command.
  for pid in "${FOLLOWER_LOAD_SECRET_JOB_PIDS[@]}"; do
    echo "Cleaning up Follower load secret job, PID: $pid"
    kill -9 "$pid"
  done
}

main() {
  echo "Beginning script: $0"
  
  if [[ -z "$MAX_ATTEMPTS" ]]; then
    echo "FATAL: MAX_ATTEMPTS must be specified as --max-attempts"
    exit 1
  fi

  if [[ -z "$POLICY_COUNT" ]]; then
    echo "FATAL: POLICY_COUNT must be specified as --policy-count"
    exit 1
  fi

  if [[ -z "$SECRET_COUNT" ]]; then
    echo "FATAL: SECRET_COUNT must be specified as --secret-count"
    exit 1
  fi

  if [[ -z "$FOLLOWER_COUNT" ]]; then
    echo "FATAL: FOLLOWER_COUNT must be specified as --follower-count"
    exit 1
  fi

  echo "Will attempt to load '${POLICY_COUNT}' policies each containing '${SECRET_COUNT}' secrets against '${FOLLOWER_COUNT}' Followers with a max retry of '${MAX_ATTEMPTS}' attempts..."
  reset_policy

  for i in $(seq 1 "$POLICY_COUNT"); do
    local dynamic_branch="policy-$i"
    local secret_id
    local secret_value
    local token

    token=$(get_conjur_access_token)
    if [[ -z "$token" ]]; then
      echo "FATAL: Failed to get Conjur Access Token!"
      exit 1
    fi

    load_policy

    for j in $(seq 1 "$SECRET_COUNT"); do
      # Generate a timestamp: Unix timestamp in seconds + milliseconds (last 3 digits)
      secret_id=$(urlencode_forward_slashes_only "${BASE_POLICY_BRANCH}/${dynamic_branch}/secret-${j}")
      secret_value=$(date +%s)$(awk -v min=0 -v max=999 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')

      set_secrets
      verify_secrets_on_followers
    done
  done

  echo "SUCCESS: All secrets were successfully replicated to all Followers."
  echo "DONE."
}

reset_policy (){
    echo "Resetting policy branch '${BASE_POLICY_BRANCH}'..."
    bin/load-dynamic-policy --reset --branch "${BASE_POLICY_BRANCH}"
    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to reset policy branch '${BASE_POLICY_BRANCH}!"
      exit 1
    fi
    echo -e "\nPolicy branch '${BASE_POLICY_BRANCH}' was reset successfully." 
}

load_policy (){
    echo "Loading policy for '${BASE_POLICY_BRANCH}/${dynamic_branch}'..."
    bin/load-dynamic-policy --branch "${BASE_POLICY_BRANCH}" --id "${dynamic_branch}" --secret-count "${SECRET_COUNT}"
    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to load dynamic policy '${BASE_POLICY_BRANCH}/${dynamic_branch}'!"
      exit 1
    fi
    echo -e "\nDynamic policy '${BASE_POLICY_BRANCH}/${dynamic_branch}' was loaded successfully." 
}

set_secrets(){
  echo "Loading secret '$secret_id' with value '$secret_value'..."
  bin/load-dynamic-policy-secret --id "$secret_id" --value "$secret_value" --token "$token"
  if [ $? -ne 0 ]; then
    echo -e "\nFATAL: Failed to load dynamic secret '$secret_id'!"
    exit 1
  fi
  echo -e "\nDynamic secret '$secret_id' was loaded successfully."
}

verify_secrets_on_followers() {
  echo "Begin testing Appliance Follower replciation for secret '$secret_id' with value '$secret_value'..."
  for ((j=1; j<=FOLLOWER_COUNT; j++))
  do
    # Execute the following in parallel...
    local follower_hostname

    follower_hostname="conjur-follower-${j}.mycompany.local"
    echo "[$follower_hostname] Starting job to get secret from follower $follower_hostname..."

    # This is a job...
    (
      for ((k=1; k<=MAX_ATTEMPTS; k++))
      do
        local token_from_follower
        local value_on_follower

        echo "[$follower_hostname] (Attempt: $k/$MAX_ATTEMPTS) - Begin checking secret '$secret_id' on follower '$follower_hostname'..."

        token_from_follower=$(get_conjur_access_token_from_follower "$follower_hostname")
        value_on_follower=$(get_secret_from_follower "$follower_hostname" "$secret_id" "$token_from_follower")

        echo "[$follower_hostname] [DEBUG] Recieved value from follower: $value_on_follower"

        # Test the value received from the Follower
        if [[ "$value_on_follower" == "Malformed authorization token" ]]; then
          # If this occurs, it is likely a developer error
          echo "[$follower_hostname] (Attempt: $k/$MAX_ATTEMPTS) - FATAL: the token used to authenticate with the Follower is invalid -- disregarding MAX_ATTEMPTS and exiting..."
          exit 1
        elif [[ "$value_on_follower" == "$secret_value" ]]; then
          echo "[$follower_hostname] (Attempt: $k/$MAX_ATTEMPTS) - Successfully replicated secret '$secret_id' with value '$value_on_follower' to follower '$follower_hostname'."
          break
        elif [[ "$k" -eq $MAX_ATTEMPTS ]]; then
          echo "[$follower_hostname] (Attempt: $k/$MAX_ATTEMPTS) - FATAL: Follower $follower_hostname failed to replicate '$secret_id'. Expected '$secret_id' to be '$secret_value', got '$value_on_follower'..."

          # Make visible the situation documented above
          if [[ "$value_on_follower" == "Unauthorized: Invalid token" ]]; then
            echo "[$follower_hostname] (Attempt: $k/$MAX_ATTEMPTS) - WARNING: it seems like the Follower is still replicating, and the resources associated with this token are not yet available. This might be a transient issue that can be resolved by increasing 'MAX_ATTEMPTS', or the Follower might be unhealthy."
          fi
          exit 1
        fi

        echo "[$follower_hostname] (Attempt: $k/$MAX_ATTEMPTS) - Retrying in 3 seconds..."
        sleep 3
      done
    ) &
    FOLLOWER_LOAD_SECRET_JOB_PIDS+=("$!")
  done

  # Wait without blocking, in case SIGINT is given, so trap can be called.
  # Otherwise, if a job has failed, exit the script appropriately.
  while true; do
    all_jobs_done=true
    for pid in "${FOLLOWER_LOAD_SECRET_JOB_PIDS[@]}"; do
      if kill -0 "$pid" 2> /dev/null; then
        all_jobs_done=false
      else
        wait $pid
        exit_status=$?
        if [ $exit_status -ne 0 ]; then
          echo "FATAL: A Follower failed to replicate! Exiting..."
          exit $exit_status
        fi
      fi
    done
    if $all_jobs_done; then
      break
    fi
    sleep 1
  done
}

# Conjur Access Tokens work across all Leaders/Followers. Let's get a token
# one time, and refresh it as needed. Returns a base64 encoded token.
get_conjur_access_token() {
  local docker_leader_container
  local api_key

  docker_leader_container=$(discover_leader_container)
  api_key=$(docker compose exec "$docker_leader_container" curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k https://localhost/authn/$CONJUR_ACCOUNT/login)
  docker compose exec "$docker_leader_container" curl \
        --max-time 3 \
        --silent \
        --insecure \
        --request POST \
        --data "$api_key" \
        "https://localhost/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate" | base64 | tr -d "[:space:]"
}

get_conjur_access_token_from_follower() {
  TARGET_HOST="$1"
  API_KEY=$(docker compose exec "$TARGET_HOST" curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k "https://$TARGET_HOST/authn/$CONJUR_ACCOUNT/login")
  docker compose exec "$TARGET_HOST" curl \
        --max-time 3 \
        --silent \
        --insecure \
        --request POST \
        --data "$API_KEY" \
        "https://$TARGET_HOST/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate" | base64 | tr -d "[:space:]"
}

get_secret_from_follower() {
  local follower_hostname="$1"
  local secret_id="$2"
  local token="$3"
  local docker_leader_container

  docker_leader_container=$(discover_leader_container)

  docker compose exec "$docker_leader_container" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --header 'Authorization: Token token=\"$token\"' \
      https://$follower_hostname/secrets/$CONJUR_ACCOUNT/variable/$secret_id
  "
}

while true ; do
  case "$1" in
    --policy-count ) shift; POLICY_COUNT="$1" ; shift ;;
    --follower-count ) shift; FOLLOWER_COUNT="$1" ; shift ;;
    --secret-count ) shift; SECRET_COUNT="$1" ; shift ;;
    --max-attempts ) shift; MAX_ATTEMPTS="$1" ; shift ;;
     * ) if [ -z "$1" ]; then break; else echo "$1 is not a valid option"; exit 1; fi;;
  esac
done

trap cleanup_background_jobs SIGINT

main

