#!/usr/bin/env bash

# USAGE
#
# Given a SECRET_COUNT, dynamically generates a Conjur Policy branch
# for the given counter. Each secret is set on the Leader, and then checked
# on each of the Followers in parallel (with up to 5 retries). If any one
# Follower fails to replicate the secret, this script will fail.
#
# IMPORTANT: the $BASE_POLICY_BRANCH is reset per run of this script. It will
# remain after the script is run. This is intentional so that
# `test-table-rows-match` has data to work with.
#
# ./bin/test-secret-replication.sh --secret-count <SECRET_COUNT> --follower-count <FOLLOWER_COUNT>
# ./bin/test-secret-replication.sh --secret-count 1 --follower-count 1
# ./bin/test-secret-replication.sh --secret-count 5 --follower-count 5
# ./bin/test-secret-replication.sh --secret-count 5 --follower-count 10
#

# Always work from repo root directory
cd "$(dirname ${0})/..";

source ./bin/functions
source ./bin/utils.sh

DOCKER_LEADER_CONTAINER="conjur-master-1.mycompany.local"
CONJUR_USER="admin"
CONJUR_ACCOUNT="demo"
CONJUR_PASSWORD="MySecretP@ss1"
BASE_POLICY_BRANCH="replication-test"
TEST_POLICY_BRANCH_PREFIX="policy-"
MAX_ATTEMPTS=

# Use this to hide WARN from docker compose...
# WARN[0000] The "VERSION" variable is not set. Defaulting to a blank string. 
export VERSION=

FOLLOWER_COUNT=
SECRET_COUNT=

main() {
  echo "Beginning script: $0"
  
  if [[ -z "$MAX_ATTEMPTS" ]]; then
    echo "FATAL: MAX_ATTEMPTS must be specified as --max-attempts"
    exit 1
  fi

  if [[ -z "$SECRET_COUNT" ]]; then
    echo "FATAL: SECRET_COUNT must be specified as --secret-count"
    exit 1
  fi

  if [[ -z "$FOLLOWER_COUNT" ]]; then
    echo "FATAL: FOLLOWER_COUNT must be specified as --follower-count"
    exit 1
  fi

  TOKEN=$(get_conjur_access_token)
  if [[ -z "$TOKEN" ]]; then
    echo "FATAL: Failed to get Conjur Access Token!"
    exit 1
  fi

  echo "Will attempt to load '${SECRET_COUNT}' policies/secrets against '${FOLLOWER_COUNT}' Followers with a max retry of '${MAX_ATTEMPTS}' attempts..."

  # Reset the base policy branch
  echo "Replacing base policy..."
  replace_base_policy

  # Create the base branch where tests will take place on...
  echo "Loading base policy..."
  load_base_policy

  for i in $(seq 1 "$SECRET_COUNT"); do
    # Refresh the Conjur Access Token...
    TOKEN=$(get_conjur_access_token)
    if [[ -z "$TOKEN" ]]; then
      echo "FATAL: Failed to get Conjur Access Token!"
      exit 1
    fi

    echo "Loading secret $i/$SECRET_COUNT..."
    echo "[DEBUG] USING TOKEN: $TOKEN"
    DYNAMIC_BRANCH="${TEST_POLICY_BRANCH_PREFIX}${i}"
    POLICY_FILE=$(get_dynamic_policy "$i")

    echo "Loading the following policy..."
    echo "$POLICY_FILE"

    load_dynamic_policy "$BASE_POLICY_BRANCH" "$POLICY_FILE"
    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to load sample policy!"
      exit 1
    fi
    echo -e "\nDynamic policy '$DYNAMIC_BRANCH' was loaded successfully."

    # Generate a timestamp: Unix timestamp in seconds + milliseconds (last 3 digits)
    SECRET_VALUE=$(date +%s)$(awk -v min=0 -v max=999 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
    SECRET_IDENTIFIER=$(urlencode_forward_slashes_only "${BASE_POLICY_BRANCH}/${DYNAMIC_BRANCH}/secret_${i}")

    echo "In the Leader, updating secret '$SECRET_IDENTIFIER' to: $SECRET_VALUE"
    set_secret "$SECRET_IDENTIFIER" "$SECRET_VALUE"

    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to set secret in the Leader!"
      exit 1
    fi
    echo -e "\nSecret was set successfully in the Leader!"

    pids=()
    for ((j=1; j<=FOLLOWER_COUNT; j++))
    do
      # Execute the following in parallel...
      FOLLOWER_HOSTNAME="conjur-follower-${j}.mycompany.local"
      echo "[$FOLLOWER_HOSTNAME] Starting job to set secret on follower $FOLLOWER_HOSTNAME..."
      (
        for ((k=1; k<=MAX_ATTEMPTS; k++))
        do
          # This test has been encountering issues where:
          #
          # 1) A Token provided by a Leader is seen as invalid, but the token
          # works for other Followers. This is seen in the Follower log:
          #
          # conjur-follower-3.mycompany.local-1  | <14>1 2024-06-04T22:37:02.000+00:00 ffe6d49725ac conjur-possum 1058 - [meta sequenceId="39"] [origin=12.16.23.11] [request_id=bc42f74e-3da1-478e-b47d-b103b7745f33] [tid=1070] Started GET "/secrets/demo/variable/replication-test%2Fpolicy-1%2Fsecret_1" for 12.16.23.11 at 2024-06-04 22:37:02 +0000
          # conjur-follower-3.mycompany.local-1  | <13>1 2024-06-04T22:37:03.622+00:00 ffe6d49725ac nginx - - [meta sequenceId="40"] 12.16.23.11 "-" "GET /secrets/demo/variable/replication-test%2Fpolicy-1%2Fsecret_1 HTTP/1.1" 401 27 "-" "curl/7.81.0" 0.028 0.028
          #
          # 2) A token provided by a Follower is seen as invalid. This is seen
          # in the Follower log:
          #
          # conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="171"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094] Started GET "/authn/demo/login" for 12.16.23.11 at 2024-06-04 22:57:32 +0000
          # conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="172"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094] Processing by AuthenticateController#login as */*
          # conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="173"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094]   Parameters: {:controller=>"authenticate", :action=>"login", :authenticator=>"authn", :account=>"demo"}
          # conjur-follower-2.mycompany.local-1  | <14>1 2024-06-04T22:57:32.000+00:00 9abb871007d8 conjur-possum 1071 - [meta sequenceId="174"] [origin=12.16.23.11] [request_id=174d748f-60f7-493e-802f-b2de7aaf16c3] [tid=1094] CONJ00047I Login Error: #<Errors::Authentication::Security::AccountNotDefined: CONJ00008E Account 'demo' is not defined in Conjur>
          #
          # This seems to indicate that a Follower might be in the process of
          # replicating (healthily) still... so increase MAX_ATTEMPTS
          # reasonably.
          #
          TOKEN_FROM_FOLLOWER=$(get_conjur_access_token_from_follower "$FOLLOWER_HOSTNAME")

          echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - Begin checking secret '$SECRET_IDENTIFIER' on follower '$FOLLOWER_HOSTNAME'..."
          echo "[$FOLLOWER_HOSTNAME] [DEBUG] USING TOKEN_FROM_FOLLOWER: $TOKEN_FROM_FOLLOWER"

          FOLLOWER_SECRET_VALUE=$(get_secret_from_follower "$FOLLOWER_HOSTNAME" "$SECRET_IDENTIFIER")

          if [[ "$FOLLOWER_SECRET_VALUE" == "$SECRET_VALUE" ]]; then
            echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - Successfully replicated secret '$SECRET_IDENTIFIER' with value '$FOLLOWER_SECRET_VALUE' to follower '$FOLLOWER_HOSTNAME'."
            break
          elif [[ "$k" -eq $MAX_ATTEMPTS ]]; then
            echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - FATAL: Follower $FOLLOWER_HOSTNAME failed to replicate secret_$i. Expected '$SECRET_IDENTIFIER' to be '$SECRET_VALUE', got '$FOLLOWER_SECRET_VALUE'..."

            # Make visible the situation documented above
            if [[ "$FOLLOWER_SECRET_VALUE" == "Unauthorized: Invalid token" ]]; then
              echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - WARNING: it seems like the Follower is still replicating, and the resources associated with this token are not yet available. This might be a transient issue that can be resolved by increasing 'MAX_ATTEMPTS', or the Follower might be unhealthy."
            fi
            exit 1
          fi

          echo "[$FOLLOWER_HOSTNAME] (Attempt: $k/$MAX_ATTEMPTS) - Retrying in 3 seconds..."
          sleep 3
        done
      ) &
      pids+=("$!")
    done

    # Wait for each job individually
    for pid in "${pids[@]}"; do
      wait "$pid"
      exit_status=$?
      if [ $exit_status -ne 0 ]; then
        echo "FATAL: A Follower failed to replicate! Exiting..."
        exit $exit_status
      fi
    done
  done
  echo "DONE."
}

replace_base_policy() {
  POLICY_BODY=$(cat <<EOF
- !policy
  id: $BASE_POLICY_BRANCH
EOF
)

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request PUT \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      --data '$POLICY_BODY' \
      https://localhost/policies/$CONJUR_ACCOUNT/policy/root
  "


  if [ $? -ne 0 ]; then
    echo -e "\nFATAL: Failed to reset base policy!"
    exit 1
  fi
  echo -e "\nBase policy was reset successfully."
}

load_base_policy() {
  POLICY_FILE=$(cat <<EOF
- !policy
  id: $BASE_POLICY_BRANCH
EOF
)

  load_dynamic_policy "root" "$POLICY_FILE"
  if [ $? -ne 0 ]; then
    echo -e "\nFATAL: Failed to load base policy!"
    exit 1
  fi
  echo -e "\nBase policy was loaded successfully."
}

# Conjur Access Tokens work across all Leaders/Followers. Let's get a token
# one time, and refresh it as needed. Returns a base64 encoded token.
get_conjur_access_token() {
  API_KEY=$(docker compose exec "$DOCKER_LEADER_CONTAINER" curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k https://localhost/authn/$CONJUR_ACCOUNT/login)
  docker compose exec "$DOCKER_LEADER_CONTAINER" curl \
        --max-time 3 \
        --silent \
        --insecure \
        --request POST \
        --data "$API_KEY" \
        "https://localhost/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate" | base64 | tr -d "[:space:]"
}

get_conjur_access_token_from_follower() {
  TARGET_HOST="$1"
  API_KEY=$(docker compose exec "$DOCKER_LEADER_CONTAINER" curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k "https://$TARGET_HOST/authn/$CONJUR_ACCOUNT/login")
  docker compose exec "$DOCKER_LEADER_CONTAINER" curl \
        --max-time 3 \
        --silent \
        --insecure \
        --request POST \
        --data "$API_KEY" \
        "https://$TARGET_HOST/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate" | base64 | tr -d "[:space:]"
}

load_dynamic_policy() {
  POLICY_BRANCH="$1"
  POLICY_BODY="$2"

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request POST \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      --data '$POLICY_BODY' \
      https://localhost/policies/$CONJUR_ACCOUNT/policy/$POLICY_BRANCH
  "
}

get_dynamic_policy() {
  COUNTER="$1"
  cat <<EOF
- !policy
  id: $DYNAMIC_BRANCH
  annotations:
    description: Namespace defs for the Conjur cluster in dev
  body:
    - !variable
      id: secret_$COUNTER
      annotations:
        description: secret_$COUNTER description

    - !host
      id: host_$COUNTER
      annotations:
        description: host_$COUNTER description

    - !group
      id: group_$COUNTER
      annotations:
        description: group_$COUNTER description

    - !permit
      role: !group group_$COUNTER
      privilege: [ read, execute ]
      resource: !variable secret_$COUNTER
    - !grant
      role: !group group_$COUNTER
      member: !host host_$COUNTER
EOF
}

set_secret() {
  IDENTIFIER="$1"
  VALUE="$2"

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request POST \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      --data '$VALUE' \
      https://localhost/secrets/$CONJUR_ACCOUNT/variable/$IDENTIFIER
  "
  
}

get_secret_from_follower() {
  FOLLOWER_HOSTNAME="$1"
  IDENTIFIER="$2"

  docker compose exec "$DOCKER_LEADER_CONTAINER" sh -c "
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --header 'Authorization: Token token=\"$TOKEN\"' \
      https://$FOLLOWER_HOSTNAME/secrets/$CONJUR_ACCOUNT/variable/$IDENTIFIER
  "
  
}

# WARNING: this is naive and only encodes forward slashes, and no other
# characters!
urlencode_forward_slashes_only() {
    local string="$1"
    echo "$string" | sed 's|/|%2F|g'
}

while true ; do
  case "$1" in
    --follower-count ) shift; FOLLOWER_COUNT="$1" ; shift ;;
    --secret-count ) shift; SECRET_COUNT="$1" ; shift ;;
    --max-attempts ) shift; MAX_ATTEMPTS="$1" ; shift ;;
     * ) if [ -z "$1" ]; then break; else echo "$1 is not a valid option"; exit 1; fi;;
  esac
done

main

