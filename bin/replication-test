#!/usr/bin/env bash

# Fail early.
set -e

# USAGE
#
# This restores a Leader from backup, deploys and configures a number of
# Followers, and runs a series of tests to verify that replication is working
# as expected. It also monitors the host for system resource utilization,
# the container logs, and outputs them into a single tarball.
#
# VERSION=5.0-stable FOLLOWER_COUNT=2 ./bin/replication-test
# VERSION=13.3.0 FOLLOWER_COUNT=2 ./bin/replication-test
#
# Useful for when only testing changes to tests or the test harness itself:
# USE_EXISTING_ENVIRONMENT=true ./bin/replication-test
#

# Always work from repo root directory
cd "$(dirname ${0})/..";

source ./bin/functions
source ./bin/utils.sh

LOG_DIR="$(appliance_log_dir)"
RESOURCE_UTLIZATION_LOG_DIR="$LOG_DIR/resources"
TOP_LOG_DIR="$RESOURCE_UTLIZATION_LOG_DIR/top"
DOCKER_STATS_LOG_DIR="$RESOURCE_UTLIZATION_LOG_DIR/docker_stats"
REPLICATION_LOG_STATS_DIR="$LOG_DIR/replication"
PG_ID_LOG_DIR="$LOG_DIR/pg_identifier"
ARCHIVE_DIR="tmp/artifacts"

USE_EXISTING_ENVIRONMENT="${USE_EXISTING_ENVIRONMENT:-false}"
VERSION="${VERSION:-5.0-stable}"
FOLLOWER_COUNT="${FOLLOWER_COUNT:-2}"
LEADER_COUNT="${LEADER_COUNT:-3}"
POLICY_COUNT="${REPLICATION_POLICY_COUNT:-2}"
SECRET_COUNT="${REPLICATION_SECRET_COUNT:-2}"
RESOURCE_INTERVAL="${RESOURCE_INTERVAL:-60}"
MAX_ATTEMPTS="${MAX_ATTEMPTS:-10}"
# The timeout in seconds to wait for the all Followers to be deployed
# 10 Minute Default
CONFIGURE_FOLLOWER_TIMEOUT=${CONFIGURE_FOLLOWER_TIMEOUT:-600}

# Use this to hide WARN from docker compose...
# WARN[0000] The "VERSION" variable is not set. Defaulting to a blank string.
export VERSION

pid=""

# Initialize two indexed arrays to hold the test command names and their
# exit codes
TEST_COMMANDS=()
EXIT_CODES_FIRST_RUN=()
EXIT_CODES_SECOND_RUN=()

finish() {
  # Re-enable exit on error, in case any of these commands fail.
  set -e
  exit_code=$1

  # If a background process PID was stored, kill it (do not fail script if it is not found)
  if [ -n "$pid" ]; then
    echo "Killing resource monitor: $pid..."
    kill $pid || true
  fi

  ./bin/create-log-artifacts --log-directory "$LOG_DIR" --follower-count  "${FOLLOWER_COUNT}"
  print_test_suite_summary

  teardown_compose_environment
  determine_exit_code "$exit_code"
  exit $?
}

main(){
  local leader_log_dir="$LOG_DIR/logs/leader"
  local follower_log_dir="$LOG_DIR/logs/follower"

  trap 'finish $?' EXIT

  TEST_COMMANDS+=("./bin/test-follower-pg-identifier --follower-count \"${FOLLOWER_COUNT}\"")
  TEST_COMMANDS+=("./bin/dump-appliance-health-and-info --follower-count \"${FOLLOWER_COUNT}\"")
  TEST_COMMANDS+=("./bin/test-secret-replication --max-attempts \"${MAX_ATTEMPTS}\" --policy-count \"${POLICY_COUNT}\" --secret-count \"${SECRET_COUNT}\" --follower-count \"${FOLLOWER_COUNT}\"")
  TEST_COMMANDS+=("./bin/test-table-rows-match --follower-count \"${FOLLOWER_COUNT}\" --max-attempts \"${MAX_ATTEMPTS}\"")
  TEST_COMMANDS+=("./bin/dump-leader-logs --no-fail --log-directory \"$leader_log_dir\"")
  TEST_COMMANDS+=("./bin/dump-appliance-follower-logs --no-fail --log-directory \"$follower_log_dir\" --follower-count \"${FOLLOWER_COUNT}\"")
  TEST_COMMANDS+=("./bin/test-leader-logs-for-replication-slot-errors --log-directory \"$leader_log_dir\"")
  TEST_COMMANDS+=("./bin/test-appliance-follower-logs-for-replication-slot-errors --log-directory \"$follower_log_dir\"")

  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT'... Setting RESOURCE_INTERVAL to '1'..."
    RESOURCE_INTERVAL="1"
  fi

  if ! command -v timeout >/dev/null 2>&1; then
    echo "FATAL: the timeout command is not available which is a requirement for this script."
    exit 1
  fi

  echo "Running replication tests with '${FOLLOWER_COUNT}' Follower(s) on Appliance Version '${VERSION}'..."

  echo "Removing old logs from: $LOG_DIR"
  rm -rf "$LOG_DIR"

  mkdir -p "$LOG_DIR"
  mkdir -p "$ARCHIVE_DIR"
  mkdir -p "$TOP_LOG_DIR"
  mkdir -p "$DOCKER_STATS_LOG_DIR"
  mkdir -p "$PG_ID_LOG_DIR"

  teardown_compose_environment

  # Exclude the grep command and the current process
  echo "Listening for orphaned resource monitoring processes from this script..."
  echo "WARNING: anything is listening below, we'll want to kill those!"
  ps -a | grep "$0" | grep -v "grep" | grep -v "$$" || true
  echo "Done listening."

  # Deploy the Leader (including loadbalancer)
  deploy_and_restore_leader

  record_resource_utilization &
  pid=$!
  echo "Starting resource monitor: $pid"
  echo "Provisioning Follower(s) using tag: '${VERSION}'..."
  echo "If any one Follower takes longer than $CONFIGURE_FOLLOWER_TIMEOUT seconds to configure, the configuration process for all Followers will be stopped."

  # The following enables us to kill long-running configurations (hanging).
  # This allows the pipeline to continue, fail, and for artifacts to still be
  # generated.
  deploy_followers

  # This is a Developer Exprience option for using USE_EXISTING_ENVIRONMENT
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    local interval=10
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT'... Sleeping for '$interval' seconds to let the resource monitor get some ticks in..."
    echo "Press any key to proceed immediately, or wait '$interval' seconds to proceed automatically."
    if ! read -t "$interval" -s; then
      echo "Proceeding..."
    fi
  fi

  # Run all test suite commands and capture their exit codes. Any failure
  # does not prevent the following tests from running.
  set +e
  announce "BEGIN TEST SUITE - BEFORE FAILOVER"
  for i in "${!TEST_COMMANDS[@]}"; do
    announce "BEGIN TEST: ${TEST_COMMANDS[$i]}"
    # shellcheck disable=SC2086
    eval ${TEST_COMMANDS[$i]}
    # shellcheck disable=SC2004
    EXIT_CODES_FIRST_RUN[$i]=$?
  done

  echo "Triggering a Leader failover..."
  perform_failover

  # Wait 5 minutes for all Followers to begin rebasing
  echo "Waiting 5 minutes for Follower(s) to begin rebasing..."
  sleep 300

  echo "Waiting for Follower(s) to become healthy after rebasing..."
  wait_for_followers

  announce "BEGIN TEST SUITE - AFTER FAILOVER"
  for i in "${!TEST_COMMANDS[@]}"; do
    announce "BEGIN TEST: ${TEST_COMMANDS[$i]}"
    # shellcheck disable=SC2086
    eval ${TEST_COMMANDS[$i]}
    # shellcheck disable=SC2004
    EXIT_CODES_SECOND_RUN[$i]=$?
  done

  echo "Tests are finished executing!"
  echo "DONE."
}

teardown_compose_environment() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping teardown of the Compose environment..."
    return
  fi
  ./bin/dap --stop || true
}

deploy_and_restore_leader() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping deployment and restoration of Leader..."
    return
  fi

  echo "Deploying the Leader using tag: '${VERSION}'..."
  bin/dap --provision-master --version "$VERSION"

  # The most recent backup is used from system/backup
  echo "Restoring the Leader from backup using tag: '${VERSION}'..."
  bin/dap --restore-from-backup --version "$VERSION"

  echo "Importing certificates..."
  bin/dap --import-custom-certificates --version "$VERSION"
  bin/dap --wait-for-master

  echo "Deploying the Standbys..."
  bin/dap --provision-standbys --version "$VERSION"
  bin/dap --wait-for-master

  echo "Enabling auto-failover..."
  bin/dap --enable-auto-failover --auto-failover-ttl 60

  echo "Waiting for healthy cluster..."
  bin/dap --wait-for-master
}

deploy_followers() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping deployment of Followers..."
    return
  fi

  set +e
  { timeout --foreground "$CONFIGURE_FOLLOWER_TIMEOUT" ./bin/dap --provision-follower --version "${VERSION}" --follower-count "${FOLLOWER_COUNT}"; exit_status=$?; }
  set -e
  if [ $exit_status -eq 124 ]; then
    echo "FATAL: Timeout of '$CONFIGURE_FOLLOWER_TIMEOUT' exceeded when provisioning Follower(s)!"
    exit 1
  elif [ $exit_status -eq 0 ]; then
      echo "SUCCESS: Follower(s) were succesfully configured completed before timeout!"
  else
      echo "FATAL: Failed to configure Follower(s) with error: $exit_status"
      exit 1
  fi
}

perform_failover() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping triggering auto-failover..."
    return
  fi

  # Trigger a failover and wait for the cluster to become healthy again
  bin/dap --trigger-failover
  sleep 5
  bin/dap --wait-for-master
}

wait_for_followers() {
  for ((i=1; i<=FOLLOWER_COUNT; i++))
  do
    echo "Waiting for Follower conjur-follower-${i}.mycompany.local to be healthy..."
    wait_for_follower "conjur-follower-${i}.mycompany.local"
  done
}

wait_for_follower() {
  local follower_hostname=$1
  local container_id
  local attempts=0
  local max_attempts=180

  container_id=$(docker compose ps -q $follower_hostname)
  if [ -z "$container_id" ]; then
    echo "WARNING: No container ID found for service '$follower_hostname' (it is not running), skipping!"
    return
  fi

  while true; do
    attempts=$((attempts + 1))
    if [ $attempts -gt $max_attempts ]; then
      echo "FATAL: Follower '$follower_hostname' did not become healthy after '$max_attempts' attempts!"
      exit 1
    fi

    echo "Checking Follower '$follower_hostname' health status (attempt $attempts/$max_attempts)..."
    if docker compose exec "$follower_hostname" curl -k --fail-with-body https://localhost/health &>/dev/null; then
      echo "Follower '$follower_hostname' is healthy!"
      break
    fi

    echo "Follower '$follower_hostname' is not healthy yet, waiting 10 seconds before trying again..."
    sleep 10
  done

}

# IMPORTANT: this is all done in sequence, each statistic is not a separate
# process!
record_resource_utilization() {
  # Suppress output from stdout
  set +x
  while true; do
    snapshot_top > /dev/null 2>&1
    snapshot_docker_stats > /dev/null 2>&1
    snapshot_leader_replication_status > /dev/null 2>&1
    snapshot_follower_replication_status > /dev/null 2>&1
    snapshot_leader_pg_identifier > /dev/null 2>&1
    snapshot_follower_pg_identifier > /dev/null 2>&1
    sleep "$RESOURCE_INTERVAL"
  done
}

snapshot_top() {
  timestamp=$(utc_timestamp)
  xtop > "$TOP_LOG_DIR/$timestamp.log"
}

snapshot_docker_stats() {
  timestamp=$(utc_timestamp)
  docker stats --no-stream > "$DOCKER_STATS_LOG_DIR/$timestamp.log"
}

# Print information of the replication status of the Leader
snapshot_leader_replication_status() {
  local log_dir

  timestamp=$(utc_timestamp)

  # Collect the replication status from each leader container
  for ((i=1; i<=LEADER_COUNT; i++)); do
    local leader_container="conjur-master-${i}.mycompany.local"

    container_id=$(docker compose ps -q $leader_container)
    if [ -z "$container_id" ]; then
      echo "WARNING: No container ID found for service '$leader_container' (it is not running), skipping!"
      continue
    fi

    log_dir="$REPLICATION_LOG_STATS_DIR/leader/$leader_container"
    pg_stat_replication_log_dir="$log_dir/pg_stat_replication"
    pg_stat_replication_log_dir_log_file="$pg_stat_replication_log_dir/$timestamp.log"
    pg_stat_activity_log_dir="$log_dir/pg_stat_activity"
    pg_stat_activity_log_dir_log_file="$pg_stat_activity_log_dir/$timestamp.log"

    mkdir -p "$pg_stat_replication_log_dir"
    mkdir -p "$pg_stat_activity_log_dir"

    docker compose exec -T "$leader_container" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_stat_replication) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$leader_container" bash -c "cat /tmp/output.csv" | tee "$pg_stat_replication_log_dir_log_file" || true

    docker compose exec -T "$leader_container" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_stat_activity) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$leader_container" bash -c "cat /tmp/output.csv" | tee "$pg_stat_activity_log_dir_log_file" || true
  done
}

# Print information of the replication status of each Follower
# WARNING: at scale, this will output a lot of files (2 per Follower)!
snapshot_follower_replication_status() {
  for ((i=1; i<=FOLLOWER_COUNT; i++))
  do
    local log_dir
    local follower_hostname="conjur-follower-${i}.mycompany.local"
    timestamp=$(utc_timestamp)
    log_dir="$REPLICATION_LOG_STATS_DIR/follower/$follower_hostname"
    pg_stat_subscription_log_dir="$log_dir/pg_stat_subscription_log_dir"
    pg_subscription_rel_log_dir="$log_dir/pg_subscription_rel"
    pg_subscription_log_dir="$log_dir/pg_subscription"

    container_id=$(docker compose ps -q $follower_hostname)
    if [ -z "$container_id" ]; then
      echo "WARNING: No container ID found for service '$follower_hostname' (it is not running), skipping!"
      continue
    fi

    mkdir -p "$pg_stat_subscription_log_dir"
    mkdir -p "$pg_subscription_rel_log_dir"
    mkdir -p "$pg_subscription_log_dir"

    docker compose exec -T "$follower_hostname" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_stat_subscription) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$follower_hostname" bash -c "cat /tmp/output.csv" | tee "$pg_stat_subscription_log_dir/$timestamp.log" || true

    docker compose exec -T "$follower_hostname" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_subscription_rel) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$follower_hostname" bash -c "cat /tmp/output.csv" | tee "$pg_subscription_rel_log_dir/$timestamp.log" || true

    docker compose exec -T "$follower_hostname" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_subscription) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$follower_hostname" bash -c "cat /tmp/output.csv" | tee "$pg_subscription_log_dir/$timestamp.log" || true
  done
}

snapshot_leader_pg_identifier() {
  local log_dir

  timestamp=$(utc_timestamp)

  # Collect the identifier from each leader container
  for ((i=1; i<=LEADER_COUNT; i++)); do
    local leader_container="conjur-master-${i}.mycompany.local"

    container_id=$(docker compose ps -q $leader_container)
    if [ -z "$container_id" ]; then
      echo "WARNING: No container ID found for service '$leader_container' (it is not running), skipping!"
      continue
    fi

    log_dir="$PG_ID_LOG_DIR/leader/$leader_container"

    mkdir -p "$log_dir"

    pgid=$(docker compose exec -T "$leader_container" chpst -u postgres psql -tqc 'SELECT system_identifier FROM pg_control_system();')
    echo "Got pg identifer for Leader '$leader_container': $pgid"
    echo "$pgid" > "$log_dir/$timestamp.log" || true
  done
}

snapshot_follower_pg_identifier() {
  local log_dir

  timestamp=$(utc_timestamp)

  for ((i=1; i<=FOLLOWER_COUNT; i++))
  do
    local log_dir
    local follower_hostname="conjur-follower-${i}.mycompany.local"

    container_id=$(docker compose ps -q $follower_hostname)
    if [ -z "$container_id" ]; then
      echo "WARNING: No container ID found for service '$follower_hostname' (it is not running), skipping!"
      continue
    fi

    log_dir="$PG_ID_LOG_DIR/follower/$follower_hostname"

    mkdir -p "$log_dir"

    pgid=$(docker compose exec -T "$follower_hostname" chpst -u postgres psql -tqc 'SELECT system_identifier FROM pg_control_system();')
    echo "Got pg identifer for Follower '$follower_hostname': $pgid"
    echo "$pgid" > "$log_dir/$timestamp.log" || true
  done
}

xtop() {
  if [ "$(uname)" = "Darwin" ]; then
      # macOS
      top -l 1 -n 30 -o cpu -o mem
  else
      # Linux
      top -b -n 1 | head -n 30
  fi
}

print_test_suite_summary() {
  announce "TEST SUITE SUMMARY"
  
  for i in "${!TEST_COMMANDS[@]}"; do
    echo "Command: ${TEST_COMMANDS[$i]}"
    echo "Exit code before failover: ${EXIT_CODES_FIRST_RUN[$i]}"
    echo "Exit code after failover: ${EXIT_CODES_SECOND_RUN[$i]}"
  done
}

determine_exit_code() {
  if [ "$1" -ne 0 ]; then
    echo "Setup failed with exit code: $exit_code"
    return 1
  fi

  for exit_code in "${EXIT_CODES_FIRST_RUN[@]}"; do
    if [ "$exit_code" -ne 0 ]; then
      echo "A test failed with exit code: $exit_code"
      return 1
    fi
  done

  for exit_code in "${EXIT_CODES_SECOND_RUN[@]}"; do
    if [ "$exit_code" -ne 0 ]; then
      echo "A test failed with exit code: $exit_code"
      return 1
    fi
  done

  return 0
}

main "$@"