#!/usr/bin/env bash

# Fail early.
set -ex

# USAGE
#
# This restores a Leader from backup, deploys and configures a number of
# Followers, and runs a series of tests to verify that replication is working
# as expected. It also monitors the host for system resource utilization,
# the container logs, and outputs them into a single tarball.
#
# VERSION=5.0-stable FOLLOWER_COUNT=2 ./bin/replication-test
# VERSION=13.3.0 FOLLOWER_COUNT=2 ./bin/replication-test
#
# Useful for when only testing changes to tests or the test harness itself:
# USE_EXISTING_ENVIRONMENT=true ./bin/replication-test
#

# Always work from repo root directory
cd "$(dirname ${0})/..";

source ./bin/utils.sh

LOG_DIR="tmp/appliance"
RESOURCE_UTLIZATION_LOG_DIR="$LOG_DIR/resources"
TOP_LOG_DIR="$RESOURCE_UTLIZATION_LOG_DIR/top"
DOCKER_STATS_LOG_DIR="$RESOURCE_UTLIZATION_LOG_DIR/docker_stats"
REPLICATION_LOG_STATS_DIR="$LOG_DIR/replication"
PG_ID_LOG_DIR="$LOG_DIR/pg_identifier"
ARCHIVE_DIR="tmp/artifacts"
DOCKER_LEADER_CONTAINER="conjur-master-1.mycompany.local"

USE_EXISTING_ENVIRONMENT="${USE_EXISTING_ENVIRONMENT:-false}"
VERSION="${VERSION:-5.0-stable}"
FOLLOWER_COUNT="${FOLLOWER_COUNT:-2}"
RESOURCE_INTERVAL="${RESOURCE_INTERVAL:-60}"
MAX_ATTEMPTS="${MAX_ATTEMPTS:-10}"
# The timeout in seconds to wait for the all Followers to be deployed
# 10 Minute Default
CONFIGURE_FOLLOWER_TIMEOUT=${CONFIGURE_FOLLOWER_TIMEOUT:-600}

# Use this to hide WARN from docker compose...
# WARN[0000] The "VERSION" variable is not set. Defaulting to a blank string.
export VERSION

pid=""

finish() {
  # If a background process PID was stored, kill it (do not fail script if it is not found)
  if [ -n "$pid" ]; then
    echo "Killing resource monitor: $pid..."
    kill $pid || true
  fi

  ./bin/create-log-artifacts --follower-count  "${FOLLOWER_COUNT}"
  teardown_compose_environment
}

main(){
  trap finish EXIT

  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT'... Setting RESOURCE_INTERVAL to '1'..."
    RESOURCE_INTERVAL="1"
  fi

  if ! command -v timeout >/dev/null 2>&1; then
    echo "FATAL: the timeout command is not available which is a requirement for this script."
    exit 1
  fi

  echo "Running replication tests with '${FOLLOWER_COUNT}' Follower(s) on Appliance Version '${VERSION}'..."

  rm -rf "$LOG_DIR"

  mkdir -p "$LOG_DIR"
  mkdir -p "$ARCHIVE_DIR"
  mkdir -p "$TOP_LOG_DIR"
  mkdir -p "$DOCKER_STATS_LOG_DIR"
  mkdir -p "$PG_ID_LOG_DIR"

  teardown_compose_environment

  # Exclude the grep command and the current process
  echo "Listening for orphaned resource monitoring processes from this script..."
  echo "WARNING: anything is listening below, we'll want to kill those!"
  ps -a | grep "$0" | grep -v "grep" | grep -v "$$" || true
  echo "Done listening."

  # Deploy the Leader (including loadbalancer)
  deploy_and_restore_leader

  record_resource_utilization &
  pid=$!
  echo "Starting resource monitor: $pid"
  echo "Provisioning Follower(s) using tag: '${VERSION}'..."
  echo "If any one Follower takes longer than $CONFIGURE_FOLLOWER_TIMEOUT seconds to configure, the configuration process for all Followers will be stopped."

  # The following enables us to kill long-running configurations (hanging).
  # This allows the pipeline to continue, fail, and for artifacts to still be
  # generated.
  deploy_followers

  # This is a Developer Exprience option for using USE_EXISTING_ENVIRONMENT
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    local interval=10
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT'... Sleeping for '$interval' seconds to let the resource monitor get some ticks in..."
    echo "Press any key to proceed immediately, or wait '$interval' seconds to proceed automatically."
    if ! read -t "$interval" -s; then
      echo "Proceeding..."
    fi
  fi

  # Begin test suite
  ./bin/test-follower-pg-identifier --follower-count "${FOLLOWER_COUNT}"
  ./bin/dump-appliance-health-and-info --follower-count "${FOLLOWER_COUNT}"
  ./bin/test-table-rows-match --follower-count "${FOLLOWER_COUNT}" --max-attempts "${MAX_ATTEMPTS}"

  # These the test below depends on the appliance logs...
  ./bin/dump-appliance-logs --follower-count "${FOLLOWER_COUNT}"
  ./bin/test-appliance-logs-for-replication-slot-errors

  echo "Tests are finished executing!"
  echo "DONE."
}

teardown_compose_environment() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping teardown of the Compose environment..."
    return
  fi
  ./bin/dap --stop || true
}

deploy_and_restore_leader() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping deployment and restoration of Leader..."
    return
  fi

  echo "Deploying the Leader using tag: '${VERSION}'..."
  bin/dap --provision-master --version "$VERSION"

  # The most recent backup is used from system/backup
  echo "Restoring the Leader from backup using tag: '${VERSION}'..."
  bin/dap --restore-from-backup --version "$VERSION"

  echo "Importing certificates..."
  bin/dap --import-custom-certificates --version "$VERSION"
  bin/dap --wait-for-master

  echo "Deploying the Standbys..."
  bin/dap --provision-standbys --version "$VERSION"

  bin/dap --wait-for-master

  echo "Enabling auto-failover..."
  bin/dap --enable-auto-failover

  echo "Waiting for healthy cluster..."
  bin/dap --wait-for-master
}

deploy_followers() {
  if [ "$USE_EXISTING_ENVIRONMENT" = "true" ]; then
    echo "USE_EXISTING_ENVIRONMENT is set to '$USE_EXISTING_ENVIRONMENT', skipping deployment of Followers..."
    return
  fi

  set +e
  { timeout "$CONFIGURE_FOLLOWER_TIMEOUT" ./bin/dap --provision-follower --version "${VERSION}" --follower-count "${FOLLOWER_COUNT}"; exit_status=$?; }
  set -e
  if [ $exit_status -eq 124 ]; then
    echo "FATAL: Timeout of '$CONFIGURE_FOLLOWER_TIMEOUT' exceeded when provisioning Follower(s)!"
    exit 1
  elif [ $exit_status -eq 0 ]; then
      echo "SUCCESS: Follower(s) were succesfully configured completed before timeout!"
  else
      echo "FATAL: Failed to configure Follower(s) with error: $exit_status"
      exit 1
  fi
}

# IMPORTANT: this is all done in sequence, each statistic is not a separate
# process!
record_resource_utilization() {
  while true; do
    snapshot_top
    snapshot_docker_stats
    snapshot_leader_replication_status
    snapshot_follower_replication_status
    snapshot_leader_pg_identifier
    snapshot_follower_pg_identifier
    sleep "$RESOURCE_INTERVAL"
  done
}

snapshot_top() {
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000+00:00")
  xtop > "$TOP_LOG_DIR/$timestamp.log"
}

snapshot_docker_stats() {
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000+00:00")
  docker stats --no-stream > "$DOCKER_STATS_LOG_DIR/$timestamp.log"
}

# Print information of the replication status of the Leader
snapshot_leader_replication_status() {
  local log_dir

  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000+00:00")
  log_dir="$REPLICATION_LOG_STATS_DIR/leader/$DOCKER_LEADER_CONTAINER"
  pg_stat_replication_log_dir="$log_dir/pg_stat_replication"
  pg_stat_replication_log_dir_log_file="$pg_stat_replication_log_dir/$timestamp.log"
  pg_stat_activity_log_dir="$log_dir/pg_stat_activity"
  pg_stat_activity_log_dir_log_file="$pg_stat_activity_log_dir/$timestamp.log"

  mkdir -p "$pg_stat_replication_log_dir"
  mkdir -p "$pg_stat_activity_log_dir"

  docker compose exec -T "$DOCKER_LEADER_CONTAINER" bash -c $"
        chpst -u conjur psql -c \"\\copy (SELECT * from pg_stat_replication) To '/tmp/output.csv' With CSV HEADER\"
      " || true
  docker compose exec "$DOCKER_LEADER_CONTAINER" bash -c "cat /tmp/output.csv" | tee "$pg_stat_replication_log_dir_log_file" || true

  docker compose exec -T "$DOCKER_LEADER_CONTAINER" bash -c $"
        chpst -u conjur psql -c \"\\copy (SELECT * from pg_stat_activity) To '/tmp/output.csv' With CSV HEADER\"
      " || true
  docker compose exec "$DOCKER_LEADER_CONTAINER" bash -c "cat /tmp/output.csv" | tee "$pg_stat_activity_log_dir_log_file" || true
}

# Print information of the replication status of each Follower
# WARNING: at scale, this will output a lot of files (2 per Follower)!
snapshot_follower_replication_status() {
  for ((i=1; i<=FOLLOWER_COUNT; i++))
  do
    local log_dir
    local follower_hostname="conjur-follower-${i}.mycompany.local"
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000+00:00")
    log_dir="$REPLICATION_LOG_STATS_DIR/follower/$follower_hostname"
    pg_stat_subscription_log_dir="$log_dir/pg_stat_subscription_log_dir"
    pg_subscription_rel_log_dir="$log_dir/pg_subscription_rel"
    pg_subscription_log_dir="$log_dir/pg_subscription"

    container_id=$(docker compose ps -q $follower_hostname)
    if [ -z "$container_id" ]; then
      echo "WARNING: No container ID found for service '$follower_hostname' (it is not running), skipping!"
      continue
    fi

    mkdir -p "$pg_stat_subscription_log_dir"
    mkdir -p "$pg_subscription_rel_log_dir"
    mkdir -p "$pg_subscription_log_dir"

    docker compose exec -T "$follower_hostname" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_stat_subscription) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$follower_hostname" bash -c "cat /tmp/output.csv" | tee "$pg_stat_subscription_log_dir/$timestamp.log" || true

    docker compose exec -T "$follower_hostname" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_subscription_rel) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$follower_hostname" bash -c "cat /tmp/output.csv" | tee "$pg_subscription_rel_log_dir/$timestamp.log" || true

    docker compose exec -T "$follower_hostname" bash -c $"
          chpst -u conjur psql -c \"\\copy (SELECT * from pg_subscription) To '/tmp/output.csv' With CSV HEADER\"
        " || true
    docker compose exec "$follower_hostname" bash -c "cat /tmp/output.csv" | tee "$pg_subscription_log_dir/$timestamp.log" || true
  done
}

snapshot_leader_pg_identifier() {
  local log_dir

  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000+00:00")
  log_dir="$PG_ID_LOG_DIR/leader/$DOCKER_LEADER_CONTAINER"

  mkdir -p "$log_dir"

  pgid=$(docker compose exec -T "$DOCKER_LEADER_CONTAINER" chpst -u postgres psql -tqc 'SELECT system_identifier FROM pg_control_system();')
  echo "Got pg identifer for Leader '$DOCKER_LEADER_CONTAINER': $pgid"
  echo "$pgid" > "$log_dir/$timestamp.log" || true
}

snapshot_follower_pg_identifier() {
  local log_dir

  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000+00:00")

  for ((i=1; i<=FOLLOWER_COUNT; i++))
  do
    local log_dir
    local follower_hostname="conjur-follower-${i}.mycompany.local"

    container_id=$(docker compose ps -q $follower_hostname)
    if [ -z "$container_id" ]; then
      echo "WARNING: No container ID found for service '$follower_hostname' (it is not running), skipping!"
      continue
    fi

    log_dir="$PG_ID_LOG_DIR/follower/$follower_hostname"

    mkdir -p "$log_dir"

    pgid=$(docker compose exec -T "$follower_hostname" chpst -u postgres psql -tqc 'SELECT system_identifier FROM pg_control_system();')
    echo "Got pg identifer for Follower '$follower_hostname': $pgid"
    echo "$pgid" > "$log_dir/$timestamp.log" || true
  done
}

xtop() {
  if [ "$(uname)" = "Darwin" ]; then
      # macOS
      top -l 1 -n 30 -o cpu -o mem
  else
      # Linux
      top -b -n 1 | head -n 30
  fi
}

main "$@"