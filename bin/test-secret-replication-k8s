#!/usr/bin/env bash

# DESCRIPTION
# Given a --follower-count, --policy-count, --secret-count and --max-attempts,
# this script will:
#
# 1) Load a dynamic policy with a secret into the Leader
# 2) Set the secret on the Leader
# 3) Verify that the secret is replicated to each K8S Follower (parallel)
#
# When verifying secrets on the K8S Followers, the script will attempt to
# authenticate with the Follower to retrieve an access token.
#
# If a secret did not replicate within the --max-attempts, the script will
# fail.
#
# IMPORTANT: the $BASE_POLICY_BRANCH is reset per run of this script. It will
# remain after the script is run. This is intentional so that
# `test-table-rows-match-k8s` has data to work with.
#
# USAGE
# ./bin/test-secret-replication-k8s --max-attempts 10 --policy-count 2 --secret-count 2 --follower-count 2
#
# This test can encounter similar issues with Follower Authentication as
# described in the `test-secret-replication` script.`
#

# Always work from repo root directory
cd "$(dirname ${0})/..";

source ./bin/functions
source ./bin/utils.sh

# All Followers will query themselves for authentication/secrets
FOLLOWER_HOSTNAME="localhost:8080"
CONJUR_USER="admin"
CONJUR_ACCOUNT="demo"
CONJUR_PASSWORD="MySecretP@ss1"
BASE_POLICY_BRANCH="replication-test"
MAX_ATTEMPTS=

# Use this to hide WARN from docker compose...
# WARN[0000] The "VERSION" variable is not set. Defaulting to a blank string. 
export VERSION=
FOLLOWER_LOAD_SECRET_JOB_PIDS=()

FOLLOWER_COUNT=
SECRET_COUNT=

cleanup_background_jobs() {
  # NOTE: this will only stop the background jobs for configuring a Follower
  # from outputting to stdout if a configuration command has begun on the
  # Follower, that process will remain running within the container. Cleanup of
  # the containers is left to the --stop command.
  for pid in "${FOLLOWER_LOAD_SECRET_JOB_PIDS[@]}"; do
    echo "Cleaning up Follower load secret job, PID: $pid"
    kill -9 "$pid"
  done
}

main() {
  echo "Beginning script: $0"
  
  if [[ -z "$MAX_ATTEMPTS" ]]; then
    echo "FATAL: MAX_ATTEMPTS must be specified as --max-attempts"
    exit 1
  fi

  if [[ -z "$POLICY_COUNT" ]]; then
    echo "FATAL: POLICY_COUNT must be specified as --policy-count"
    exit 1
  fi

  if [[ -z "$SECRET_COUNT" ]]; then
    echo "FATAL: SECRET_COUNT must be specified as --secret-count"
    exit 1
  fi

  if [[ -z "$FOLLOWER_COUNT" ]]; then
    echo "FATAL: FOLLOWER_COUNT must be specified as --follower-count"
    exit 1
  fi

  echo "Will attempt to load '${POLICY_COUNT}' policies each containing '${SECRET_COUNT}' secrets against '${FOLLOWER_COUNT}' Followers with a max retry of '${MAX_ATTEMPTS}' attempts..."
  reset_policy

  for i in $(seq 1 "$POLICY_COUNT"); do
    local dynamic_branch="policy-$i"
    local secret_id
    local secret_value
    local token

    token=$(get_conjur_access_token)
    if [[ -z "$token" ]]; then
      echo "FATAL: Failed to get Conjur Access Token!"
      exit 1
    fi

    load_policy

    for j in $(seq 1 "$SECRET_COUNT"); do
      # Generate a timestamp: Unix timestamp in seconds + milliseconds (last 3 digits)
      secret_id=$(urlencode_forward_slashes_only "${BASE_POLICY_BRANCH}/${dynamic_branch}/secret-${j}")
      secret_value=$(date +%s)$(awk -v min=0 -v max=999 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')

      set_secrets
      verify_secrets_on_followers
    done
  done

  echo "SUCCESS: All secrets were successfully replicated to all Followers."
  echo "DONE."
}

reset_policy (){
    echo "Resetting policy branch '${BASE_POLICY_BRANCH}'..."
    bin/load-dynamic-policy --reset --branch "${BASE_POLICY_BRANCH}"
    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to reset policy branch '${BASE_POLICY_BRANCH}!"
      exit 1
    fi
    echo -e "\nPolicy branch '${BASE_POLICY_BRANCH}' was reset successfully." 
}

load_policy (){
    echo "Loading policy for '${BASE_POLICY_BRANCH}/${dynamic_branch}'..."
    bin/load-dynamic-policy --branch "${BASE_POLICY_BRANCH}" --id "${dynamic_branch}" --secret-count "${SECRET_COUNT}"
    if [ $? -ne 0 ]; then
      echo -e "\nFATAL: Failed to load dynamic policy '${BASE_POLICY_BRANCH}/${dynamic_branch}'!"
      exit 1
    fi
    echo -e "\nDynamic policy '${BASE_POLICY_BRANCH}/${dynamic_branch}' was loaded successfully." 
}

set_secrets(){
  echo "Loading secret '$secret_id' with value '$secret_value'..."
  bin/load-dynamic-policy-secret --id "$secret_id" --value "$secret_value" --token "$token"
  if [ $? -ne 0 ]; then
    echo -e "\nFATAL: Failed to load dynamic secret '$secret_id'!"
    exit 1
  fi
  echo -e "\nDynamic secret '$secret_id' was loaded successfully."
}

verify_secrets_on_followers() {
  echo "Begin testing K8S Follower replciation for secret '$secret_id' with value '$secret_value'..."

  RUNNING_PODS=$(get_k8s_follower_pod_names)
  echo "$RUNNING_PODS"

  RUNNING_PODS_COUNT=$(echo "$RUNNING_PODS" | wc -w | tr -d ' ')

  if [ "$RUNNING_PODS_COUNT" -ne "$FOLLOWER_COUNT" ]; then
    echo "FATAL: The number of running pods '$RUNNING_PODS_COUNT' is not equal to the expected FOLLOWER_COUNT: '${FOLLOWER_COUNT}'. Exiting..."
    exit 1
  fi

  for pod in $RUNNING_PODS; do
    # Execute the following in parallel...
    echo "[$pod] Starting job to get secret from follower $pod..."

    # This is a job...
    (
      for ((k=1; k<=MAX_ATTEMPTS; k++))
      do
        local token_from_follower
        local value_on_follower

        echo "[$pod] (Attempt: $k/$MAX_ATTEMPTS) - Begin checking secret '$secret_id' on follower '$pod'..."

        token_from_follower=$(get_conjur_access_token_from_follower "$pod")
        if [[ -z "$token_from_follower" ]]; then
          echo "[$pod] FATAL: Failed to get Conjur Access Token from follower! Retrying..."
          sleep 3
          continue
        fi

        echo "[$pod] [DEBUG] Recieved token_from_follower from follower: $token_from_follower"

        value_on_follower=$(get_secret_from_follower "$pod" "$secret_id" "$token_from_follower")
        echo "[$pod] [DEBUG] Recieved value from follower: $value_on_follower"
        # value_on_follower="qwe"

        # Test the value received from the Follower
        if [[ "$value_on_follower" == "Malformed authorization token" ]]; then
          # If this occurs, it is likely a developer error
          echo "[$pod] (Attempt: $k/$MAX_ATTEMPTS) - FATAL: the token used to authenticate with the Follower is invalid -- disregarding MAX_ATTEMPTS and exiting..."
          exit 1
        elif [[ "$value_on_follower" == "$secret_value" ]]; then
          echo "[$pod] (Attempt: $k/$MAX_ATTEMPTS) - Successfully replicated secret '$secret_id' with value '$value_on_follower' to follower '$pod'."
          break
        elif [[ "$k" -eq $MAX_ATTEMPTS ]]; then
          echo "[$pod] (Attempt: $k/$MAX_ATTEMPTS) - FATAL: Follower $pod failed to replicate '$secret_id'. Expected '$secret_id' to be '$secret_value', got '$value_on_follower'..."

          # Make visible the situation documented above
          if [[ "$value_on_follower" == "Unauthorized: Invalid token" ]]; then
            echo "[$pod] (Attempt: $k/$MAX_ATTEMPTS) - WARNING: it seems like the Follower is still replicating, and the resources associated with this token are not yet available. This might be a transient issue that can be resolved by increasing 'MAX_ATTEMPTS', or the Follower might be unhealthy."
          fi
          exit 1
        fi

        echo "[$pod] (Attempt: $k/$MAX_ATTEMPTS) - Retrying in 3 seconds..."
        sleep 3
      done
    ) &
    FOLLOWER_LOAD_SECRET_JOB_PIDS+=("$!")
  done

  # Wait without blocking, in case SIGINT is given, so trap can be called.
  # Otherwise, if a job has failed, exit the script appropriately.
  while true; do
    all_jobs_done=true
    for pid in "${FOLLOWER_LOAD_SECRET_JOB_PIDS[@]}"; do
      if kill -0 "$pid" 2> /dev/null; then
        all_jobs_done=false
      else
        wait $pid
        exit_status=$?
        if [ $exit_status -ne 0 ]; then
          echo "FATAL: A Follower failed to replicate! Exiting..."
          exit $exit_status
        fi
      fi
    done
    if $all_jobs_done; then
      break
    fi
    sleep 1
  done

  # Reset global for the next iteration
  FOLLOWER_LOAD_SECRET_JOB_PIDS=()
}

# Conjur Access Tokens work across all Leaders/Followers. Let's get a token
# one time, and refresh it as needed. Returns a base64 encoded token.
get_conjur_access_token() {
  local docker_leader_container
  local api_key

  docker_leader_container=$(discover_leader_container)
  api_key=$(docker compose exec "$docker_leader_container" curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k https://localhost/authn/$CONJUR_ACCOUNT/login)

  docker compose exec "$docker_leader_container" curl \
        --max-time 3 \
        --silent \
        --insecure \
        --request POST \
        --data "$api_key" \
        "https://localhost/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate" | base64 | tr -d "[:space:]"
}

get_conjur_access_token_from_follower() {
  follower_pod="$1"

  API_KEY=$(bin/kubectl "exec $follower_pod -n '$(_get_k8s_follower_namespace)' -c conjur -- bash -c 'curl --silent --user "$CONJUR_USER:$CONJUR_PASSWORD" -k "http://$FOLLOWER_HOSTNAME/authn/$CONJUR_ACCOUNT/login"'")
  
  bin/kubectl "exec $follower_pod -n '$(_get_k8s_follower_namespace)' -c conjur -- bash -c ' \
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --request POST \
      --data $API_KEY \
      "http://$FOLLOWER_HOSTNAME/authn/$CONJUR_ACCOUNT/$CONJUR_USER/authenticate"
  '| base64 | tr -d \"[:space:]\""
}

get_secret_from_follower() {
  local follower_pod="$1"
  local secret_id="$2"
  local token="$3"
  local command

  command="
    curl \
      --max-time 3 \
      --silent \
      --insecure \
      --header \"Authorization: Token token=\\\"$token\\\"\" \
      http://$FOLLOWER_HOSTNAME/secrets/$CONJUR_ACCOUNT/variable/$secret_id
  "

  bin/kubectl "exec '$follower_pod' -n '$(_get_k8s_follower_namespace)' -c conjur -- bash -c '$command'"
}

while true ; do
  case "$1" in
    --policy-count ) shift; POLICY_COUNT="$1" ; shift ;;
    --follower-count ) shift; FOLLOWER_COUNT="$1" ; shift ;;
    --secret-count ) shift; SECRET_COUNT="$1" ; shift ;;
    --max-attempts ) shift; MAX_ATTEMPTS="$1" ; shift ;;
     * ) if [ -z "$1" ]; then break; else echo "$1 is not a valid option"; exit 1; fi;;
  esac
done

trap cleanup_background_jobs SIGINT

main

